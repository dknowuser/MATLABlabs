%Марчук Л.Б. 5307
%Данная программа задаёт функцию на интервале (-9; 9),
%выбирает M > 10 узлов, в каждом узле "зашумляет" функцию,
%аппроксимирует набор точек базисными функциями до точности 0,01
%и вычисляет количество базисных функций для этой точности.
%В качестве нормы взята сумма попарных произведений значений функций
%в заданных точках, делённая на количество точек.

%Базисные функции:
%1, x, x^2, x^3, ...

function result = MNKA()
    %Задаём функцию
    f = @(x)sin(x);
    
    %Выводим исследуемую функцию на экран
    hold on;
    px=(-9 + 0.001):0.001:(9 - 0.001);
    plot(px, f(px), 'b');
    
    %Выбираем от 10 узлов
    M = 10 + round(rand() * 10);
    x = zeros(1, M);
    for i=1:1:M
        x(1, i) = -9 + rand() * 18;
    end;
    x = sort(x);
    
    %Вычисляем значение функции в этих узлах
    y = zeros(1, M);
    for i=1:1:M
        y(1, i) = f(x(1,i));
    end;
    
    %"Зашумляем" функцию
    for i=1:1:M
        y(1, i) = y(1, i) + 1 + rand() + 0.1*rand() + 0.01*rand();
    end;
    
    %Выводим точки
    plot(x, y, 'm*');
    
    %Достигнутая точность (D < 0.01 - выход из цикла)
    D = 1;
    
    %Количество базисных функций 
    BasisNumber = 1;
    
    %Массив значений базисных функций в заданных точках
    %Строка - базисная функция
    %Столбцы - значения базисной функции в заданных точках
    Basis = ones(1, M);
    
    while D >= 0.001
        %Ищем коэффициенты при ci
        Koeff = zeros(BasisNumber);
        for i=1:1:BasisNumber
            for j=i:1:BasisNumber
                Temp = 0;
                
                for k=1:1:M
                    Temp = Temp + Basis(i, k)*Basis(j, k);
                end;
                
                Koeff(i, j) = Temp/M;
                Koeff(j, i) = Koeff(i, j);
            end;
        end;
        
        %Находим правую часть системы уравнений
        RPart = [];
        for i=1:1:BasisNumber
            Temp = 0;
            for k=1:1:M
                Temp = Temp + Basis(i, k)*y(1, k);
            end;
            RPart = [RPart; Temp/M];
        end;
        
        %Решаем систему уравнений относительно ci
        C = Koeff\RPart;        
        C = C';
        C = flip(C);
        
        %Выводим аппроксимирующую функцию
        plot(px, polyval(C, px));
        
        %Определяем максимальную разность аппроксимирующей функции и
        %исходной
        D = 0;
        
        for i=1:1:M
            if abs(y(i) - polyval(C, x(i))) > D
                D = abs(y(i) - polyval(C, x(i)));
            end;
        end;
        
        if D >= 0.001
            %Если требуемая точность не достигнута, генерируем следующую
            %базисную функцию
            BasisNumber = BasisNumber + 1;
            
            for i=1:1:M
                Basis(BasisNumber, i) = Basis(BasisNumber - 1, i) * x(i);
            end;
        end;
    end;
    result = BasisNumber;
end